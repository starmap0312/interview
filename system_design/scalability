# vertical scaling
  enhance cpu/ram/disk: physical constraints

# horizontal scaling
  multiple servers, load balancer

  load balancer solution:

    clients <-> load balancer <-> real servers

    load balancer: public ip address, real servers: private ip addresses
    rotation policy: based on round-robin/loading
    real servers: duplicated/dedicated (multiple servers for different services, no redundancy)

  dns solution:

    clients <-> dns query
       |
       --> server1, server2, etc.

    pro: simple, dns server returns different ip in turns (BIND multiple ip addresses to server)
    con: unbalanced loading, ex. client caching ip always requests the same server 

  sticky sessions:
    cookie: a string ID generated by server to identify user session
      load balancer uses the ID to forward to the same real server
      real server uses the ID to identify the user session data
    session data: user session information is stored in a text file on server side
      stored at one shared place on server side
      use FC, iSCSI, NFS (file server), MySQL (database server)

  reliability: (reduce downtime)
    storage: RAID, use multiple drives, ex. 2TB drives * 4
      RAID 0: good performance, write to/read from 2 drives simultaneously
      RAID 1: mirror data, reliable, but waste 1 drive every 2 drives
      RAID 10: combination of RAID 0 and RAID 1
    file server
      multiple servers, sync data, replication
    database server: replication

# cookie
  designed to be a reliable mechanism for websites to remember stateful information
  1) a small piece of data sent from a website and stored in the user web browser
  2) every time the user loads the website, the browser sends the cookie back to the server to
     notify the user previous activity

  examples:
  1) items added in the shopping cart in an online store
  2) to record the user's browsing activity, ex. clicking particular buttons, logging in, or
     recording which pages were visited in the past
  3) store passwords and form content a user has previously entered, ex. credit card numbers or
     mail addresses

  tracking cookies are used to track users web browsing habits
  1) use user IP address or the referer field of the HTTP request header
  2) use cookies: 
     a) when user requests a webpage for the first time the server creates a cookie, i.e.
        a unique ID (a string of random letters and numbers) and sends it back to the browser
     b) the cookie will automatically be sent by the browser to the server every time a new page
        is requested
     c) the server will store the session data, i.e the cookie, the URL of the requested page,
        the date/time of the request in a log file
        (the server can then to find out which pages the user has visited)

# HTTP session
  1) a conversation between two or more communicating devices
  2) a sequence of network request-response transactions
  3) HTTP client initiates a request by establishing a Transmission Control Protocol (TCP)
     connection to a particular port on a server

# caching
  0) php (dyanamic content)
     ex. php, first-time need parsing; next time, directly run the ops codes
  1) html (static content)
     drawback: the page need storage if not dynamically generated, ex. MVC
  2) MySQL query cache
     MySQL mechanism: identical query results are cached in memory
  3) memcached
     connect to memcache server, which caches key/value pairs
     LRU (least recently used) pairs may be freed

# load balancing
  1) software solution
     HAProxy (high-avalibility)/ELB/LVS
  2) hardware solution
     Barracuda/Cisco/Citrix/F5

  active-active mode: traffic goes to both load balancers

                 (heart beat)
  Load Balancer <------------> Load Balancer
    (active)                     (active)

  active-passive mode: traffic goes to active balancer
    if the active LB is down, the passive LB promotes itself to active

                 (heart beat)
  Load Balancer <------------> Load Balancer
    (active)                     (passive)

# MySQL optimization
  MySQL store engine: (different underline formats)
  1) InnoDB engine: default, support transactions
  2) MyISAM engine: does not support transactions
  3) Memory engine: memory tables are stored in RAM
  4) Archive engine: compressed by default, slow, but less space

# database replication
  master-master: reads/writes go to both servers
  
                                           (replication)
  Users  -->  Load Balancer ------> Master ------------- Slave
                                |     |    (replication)
                                --> Master ------------- Slave

  master-slave: writes go to the master server, and reads go to the slave servers

                                                             (writes)
  Users  -->  Load Balancer ----> Frontend Web Servers  ---------------------> MySQL master
                            ----> Frontend Web Servers  ---------------|         |
                            ----> Frontend Web Servers  ---------------|         | (replication)
                            ----> ...      |||                                   |
                                           |||                    (reads)        |
                                           ---> Load Balancer ---------------> MySQL slave
                                                                       |-----> MySQL slave
                                                                       |-----> MySQL slave

# database partitioning

# using NoSQL instead of scaling a relational database

# being asynchronous

# two major bottlenecks
  1) handling a lot of users
  2) handling a lot of data

# database sharding
  database scaling
