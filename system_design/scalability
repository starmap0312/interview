# vertical scaling
  enhance cpu/ram/disk: physical constraints

# horizontal scaling
  multiple servers + load balancer

  load balancer solution:

    clients <-> load balancer <-> real servers
                                  real servers
                                  real servers

    load balancer (public ip address) and real servers (private ip addresses)
    rotation policy: based on round-robin or based on server loading
    real servers: duplicated or dedicated (multiple servers for different services, no redundancy)

  dns solution:

    clients <-> dns query
       |
       --> server1 ip address
           server2 ip address
           server3 ip address

    pro: simple, dns server returns different ip in turns (BIND multiple ip addresses to server)
    con: create unbalanced loading, ex. client may cache the ip and always requests the same server 

  sticky sessions:
    cookie: a string ID generated by server and stored in client, used to identify user session
      load balancer uses the ID to forward to the same real server
      real server uses the ID to identify the user session data
    session data: user session information stored on server side
      stored at one shared place on server side (ex. a text file on server)
      ex. FC, iSCSI, NFS (file server), MySQL (database server)

  reliability: (reduce downtime)
    storage: RAID, use multiple drives, ex. 2TB drives * 4
      RAID 0: good performance, write to/read from 2 drives simultaneously
      RAID 1: mirror data, reliable, but waste 1 drive every 2 drives
      RAID 10: combination of RAID 0 and RAID 1
    file server
      multiple servers, sync data, replication
    database server: replication

# cookie
  a mechanism for websites to remember stateful information
  1) a small piece of data generated by web server and stored in user browser
  2) every time the user loads the website, the browser sends the cookie back to the server
     ex. used to identify the user's previous activity

  examples:
  1) items added in the shopping cart in an online store
  2) user's browsing activity, ex. clicking particular buttons, logging in, or which pages user visited
  3) store passwords and content user previously entered, ex. credit card numbers or mail addresses

  ex. track users web browsing habits
  1) use user IP address or the referer field of the HTTP request header
  2) use tracking cookies: 
     a) when user requests a webpage for the first time the server creates a cookie, i.e.
        a unique ID (a string of random letters and numbers) and sends it back to the browser
     b) the cookie will automatically be sent by the browser to the server every time a new page
        is requested
     c) the server stores the session data, i.e. the cookie, the URL of the requested page, and
        the date/time of the request in a log file
        (so that the server can find out which pages the user visited)

# HTTP session
  1) a conversation between two or more communicating devices
  2) a sequence of network request-response transactions
  3) HTTP client initiates a request by establishing a Transmission Control Protocol (TCP)
     connection to a particular port on a server

# caching
  0) php (dyanamic content)
     ex. php, first-time need parsing; next time, directly run the ops codes
  1) html (static content) page
     drawback: need extra storage if not dynamically generated, ex. MVC
  2) MySQL query cache
     MySQL mechanism: identical query results are cached in memory
  3) memcached
     connect to memcache server: it caches key/value pairs
     LRU (least recently used) pairs may be freed

# load balancing
  1) software solution: ex. HAProxy (high-avalibility)/ELB/LVS
  2) hardware solution: ex. Barracuda/Cisco/Citrix/F5

  active-active mode: traffic goes to both load balancers

                 (heart beat)
  Load Balancer <------------> Load Balancer (active)
                               Load Balancer (active)

  active-passive mode: traffic goes to active balancer
    if the active LB is down, the passive LB promotes itself to active

                 (heart beat)
  Load Balancer <------------> Load Balancer (active)
                               Load Balancer (passive)

# MySQL optimization
  MySQL store engine: (different underline formats)
  1) InnoDB engine: (default) support transactions
  2) MyISAM engine: does not support transactions
  3) Memory engine: memory tables are stored in RAM
  4) Archive engine: compressed by default, slow, but less space

# database replication
  1) master-master: reads/writes go to both servers
  
                                           (replication)
  Users  -->  Load Balancer ------> Master ------------- Slave
                                |     |    (replication)
                                --> Master ------------- Slave

  2) master-slave: writes go to the master server, and reads go to the slave servers

                                                             (writes)
  Users  -->  Load Balancer ----> Frontend Web Servers  ---------------------> MySQL master
                            ----> Frontend Web Servers  ---------------|         |
                            ----> Frontend Web Servers  ---------------|         | (replication)
                            ----> ...      |||                                   |
                                           |||                    (reads)        |
                                           ---> Load Balancer ---------------> MySQL slave
                                                                       |-----> MySQL slave
                                                                       |-----> MySQL slave

# horizontal partitioning (sharding) vs. vertical partitioning
  1) horizontal partitioning: row-wise (sharding) 
     dividing different rows into different tables
     (i.e. replicating the schema, and then dividing the data based on a shard key)
     ex. create two partition tables for CustomersEast and CustomersWest, and a view for all customers
     ex. Range partitioning, List partitioning, Composite partitioning, Hash partitioning 
         (need to distribute load and space across shards evenly)

  2) vertical partitioning: column-wise
     dividing different columns into different tables for performance
     (i.e. dividing logical entities into different physical entities for performance and availability)
     normalization also involves splitting of columns across tables
       but vertical partitioning splits columns even when tables are already normalized

     ex. split dynamic data (slow to find, not often used) from static data (fast to find) in a table 
         performance improved when accessing only static data
         creat a view across two tables to restore the original table with a performance penalty

# scaling issues
  1) using NoSQL instead of scaling a relational database
     easier to scale, denormalize right from the beginning
  2) being asynchronous
  3) two major bottlenecks: handling a lot of users, and handling a lot of data

